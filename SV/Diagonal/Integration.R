library(rstan)
library(mcmcse)
library(MASS)
library(transport)
library(parallel)
library(deSolve)
library(coda)

source("DefinedFunctions/data.R")

#################### NUTS #############################
set.seed(1e7)
Index1 <- 1:1000
Index2 <- 1001:1003
Index3 <- 1004:1006
Index4 <- "lp__"

###################### NUTS ###################### 
rstan_options(auto_write = TRUE)
num_cores <- parallel::detectCores()
options(mc.cores = parallel::detectCores())
d <- T1+3
data = list(T1=T1,y=y)
iter0 <- 25e3
warmup0 <- 5e3
fit <- stan("SV.stan",data=data, chains=40, iter=iter0, warmup = warmup0,
            init = "random",save_dso = FALSE, verbose=TRUE,algorithm = "NUTS",
            control = list(adapt_engaged=TRUE,stepsize=0.01,adapt_delta=0.95,
                           metric="unit_e",max_treedepth=14))
source("DefinedFunctions/UandGradU.R")
source("DefinedFunctions/Leapfrog.R")
source("DefinedFunctions/LongestBatch.R")
source("DefinedFunctions/Transformation.R")
source("DefinedFunctions/SummaryFunction.R")
source("DefinedFunctions/LearnL.R")
source("DefinedFunctions/eHMC.R")
source("DefinedFunctions/eHMCq.R")
source("DefinedFunctions/eHMCu.R")


adaptation_infoTotal = get_adaptation_info(fit)
MixSampler <- function(k)
{
  set.seed(k * 1e7)
  adaptation_info <- adaptation_infoTotal[[k]]
  M0 <- strsplit(adaptation_info[[1]],"\n")[[1]][4]
  M0 <- strsplit(M0, "#")[[1]][2]
  M0 <- as.vector(as.numeric(strsplit(M0, ",")[[1]]))
  M0 <- 1/M0
  #M0  <- rep(1,d)
  feature_names0 <- names(fit)
  stepsize_trace <- attr(fit@sim$samples[[k]],"sampler_params")$stepsize__
  epsilon0 <- stepsize_trace[iter0]
  init0 <- rep(0,d)
  for(l in 1:d)
  {
    init0[l] <- (fit@sim$samples[[k]])[[l]][warmup0+1]
  }
  init0 <- as.vector(init0)
  
  
  fit0 <- LearnL(epsilon0,M0,init0,d,2e3,feature_names0,U,grad_U,LongestBatch)
  fit1 <- eHMC( fit0$L_emp,epsilon0,M0,init0,d,2e4,feature_names0,U,grad_U,Leapfrog)
  fit2 <- eHMCq(fit0$L_emp,epsilon0,M0,init0,d,2e4,feature_names0,U,grad_U,Leapfrog)
  fit3 <- eHMCu(fit0$L_emp,epsilon0,M0,init0,d,2e4,feature_names0,U,grad_U,Leapfrog)
  
  L_trace <- attr(fit@sim$samples[[k]],"sampler_params")$n_leapfrog__
  accept_trace <- attr(fit@sim$samples[[k]],"sampler_params")$accept_stat__
  CompNUTS <- sum(L_trace[-c(1:warmup0)])
  
  Xsamp_NUTS <- fit@sim$samples[[k]]
  Xsamp_NUTS <- Xsamp_NUTS[1:length(Xsamp_NUTS)]
  Xsamp_NUTS <- (t(do.call(rbind,Xsamp_NUTS)))[-c(1:warmup0),]
  NUTS_Summary <- list(Comp=CompNUTS, epsilon=epsilon0,
                       L_trace=L_trace[-c(1:warmup0)],
                       accept=mean(accept_trace[-c(1:warmup0)]),
                       statistics=SummaryFunction(Xsamp_NUTS))
  LearnL_Summary <- list(L_emp=fit0$L_emp, accept=fit0$ratio/fit0$Niter)
  eHMC_Summary   <- list(Comp=fit1$Comp, epsilon=fit1$epsilon,
                         accept=fit1$ratio_empirical, time=fit1$time,
                         statistics=fit1$Xsummary)
  eHMCq_Summary  <- list(Comp=fit2$Comp, epsilon=fit2$epsilon,
                         accept=fit2$ratio_empirical, time=fit2$time,
                         statistics=fit2$Xsummary)
  eHMCu_Summary  <- list(Comp=fit3$Comp, epsilon=fit3$epsilon,
                         accept=fit3$ratio_empirical, time=fit3$time,
                         statistics=fit3$Xsummary)
  
  return(list(NUTS_Summary=NUTS_Summary, LearnL_Summary=LearnL_Summary,
              eHMC_Summary=eHMC_Summary, eHMCq_Summary=eHMCq_Summary,
              eHMCu_Summary=eHMCu_Summary))
}



num_cores <- detectCores()

cl <- makeCluster(num_cores,type = "FORK")

Result <- parLapply(cl, 1:40, function(zz) MixSampler(zz))

save(Result, file="Result.RData")
stopCluster(cl)

print(length(Result))

